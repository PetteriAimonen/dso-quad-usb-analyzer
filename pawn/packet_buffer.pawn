/// Storage buffer for captured packets

/// Packet contents.
/// Normal byte stream, with end-of-packet info last.
static packet_data{4096};
static const packet_data_len = 4096;
static const packet_data_mask = 4095;

/// Index of captured packets (start positions and packet lengths)
static packet_index_start_pos[256];
static packet_index_length[256];
static const packet_index_len = 256;
static const packet_index_mask = 255;

/// Next packet to write.
/// These will increase endlessly, and the lowest N bits are used
/// to index into the packet buffer.
static packet_index_write_ptr = 0;
static packet_data_write_ptr = 0;

/// Fetch a packet from the decoder and add it to the packet buffer.
/// Returns index of the new packet.
packet_fetch()
{
    new length;
    new start_pos = packet_data_write_ptr;
    new start_pos_i = (start_pos & packet_data_mask);
    if (!decoder_read_packet(packet_data, length, start_pos_i,
                             packet_data_len - start_pos_i))
    {
        // Wrapped around the end of packet_data buffer
        new length2; 
        assert(decoder_read_packet(packet_data, length2, 0, packet_data_len));
        length += length2;
    }
    packet_data_write_ptr += length;
    
    new index = (packet_index_write_ptr & packet_index_mask);
    packet_index_start_pos[index] = start_pos;
    packet_index_length[index] = length;
    packet_index_write_ptr++;
    
    return index;
}

/// Check if a packet index is still valid
bool: packet_valid(index)
{
    if (index < 0 || index >= packet_index_write_ptr)
        return false;
    
    if (index + packet_index_len < packet_index_write_ptr)
        return false; // Index has been overwritten
    
    new start_pos = packet_index_start_pos[index & packet_index_mask];
    if (start_pos + packet_data_len < packet_data_write_ptr)
        return false;
    
    return true;
}

/// Get index of oldest valid packet
packet_get_oldest()
{
    if (packet_index_write_ptr == 0)
        return -1;
    
    new index = packet_index_write_ptr - packet_index_len;
    if (index < 0) index = 0;
    
    for (; index < packet_index_write_ptr; index++)
    {
        if (packet_valid(index))
            break;
    }
    
    assert(packet_valid(index));
    return index;
}

/// Get packet length
packet_length(index)
{
    if (!packet_valid(index))
        return 0;
    
    index &= packet_index_mask;
    
    return packet_index_length[index];
}

/// Get packet bytes
bool: packet_read(index, buf{}, start, length)
{
    if (!packet_valid(index))
        return false;
    
    index &= packet_index_mask;
    
    if (start + length > packet_index_length[index])
        return false;
    
    new pos = packet_index_start_pos[index] + start;
    for (new i = 0; i < length; i++)
    {
        buf{i} = packet_data{pos & packet_data_mask};
        pos++;
    }
    
    return true;
}

/// Get packet timestamp
packet_timestamp(index)
{
    new buf{4};
    if (!packet_read(index, buf, packet_length(index) - 5, 4))
        return -1;
    
    return buf{0} | (buf{1} << 8) | (buf{2} << 8) | (buf{3} << 8);
}

